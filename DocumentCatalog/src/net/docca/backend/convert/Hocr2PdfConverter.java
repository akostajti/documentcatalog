package net.docca.backend.convert;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.docca.backend.convert.hocr.HocrDocument;
import net.docca.backend.convert.hocr.HocrParser;
import net.docca.backend.convert.hocr.attributes.BoundingBox;
import net.docca.backend.convert.hocr.elements.Line;
import net.docca.backend.convert.hocr.elements.Page;
import net.docca.backend.convert.hocr.elements.Word;
import net.htmlparser.jericho.Source;
import net.htmlparser.jericho.StartTag;

import org.apache.log4j.Logger;

import com.itextpdf.text.BadElementException;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Font;
import com.itextpdf.text.FontFactory;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;

public class Hocr2PdfConverter {
	private static final Logger logger = Logger.getLogger(Hocr2PdfConverter.class);

	/**
	 * the pattern used in finding the bbox properties.
	 */
	private static final Pattern imagePattern = Pattern.compile("image\\s+([^;]+)");

	/**
	 * the default dpi value used if it cannot be derived from the image itself.
	 */
	private static final float DEFAULT_DPI = 100.0f;

	/**
	 * the default resolution of the pdf file
	 */
	private static float DEFAULT_RESOLUTION = 72.0f;

	private static final Font DEFAULT_FONT = FontFactory.getFont(FontFactory.HELVETICA, 8, Font.BOLD, CMYKColor.BLACK);

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			if(args.length < 1 || args[0] == "--help" || args[0] == "-h") {
				System.out.print(
						"Usage: java com.acoveo.hocrtopdf.HocrToPdf INPUTURL.html OUTPUTURL.pdf\n" +
						"\n" +
						"Converts hOCR files into PDF\n" +
						"\n" +
						"Example: java com.acoveo.hocrtopdf.HocrToPdf file:///home/username/hocr.html ./output.pdf\n");
				if(args.length < 1)
					System.exit(-1);
				else
					System.exit(0);
			}
			File inputHOCRFile = null;
			FileOutputStream outputPDFStream = null;
			try {
				inputHOCRFile = new File(args[0]);
			} catch (Exception e) {
				System.out.println("The first parameter has to be a valid URL");
				System.exit(-1);
			}
			try {
				outputPDFStream = new FileOutputStream(args[2]);
			} catch (FileNotFoundException e) {
				System.out.println("The second parameter has to be a valid URL");
				System.exit(-1);
			}
			
			new Hocr2PdfConverter().convertToPdf(inputHOCRFile, new File(args[1]), outputPDFStream);
		} catch (DocumentException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Processes a hOcr file (generated by tesseract)
	 * 
	 * @param hocr
	 * @param out
	 * @throws IOException
	 * @throws BadElementException
	 * @throws DocumentException
	 */
	public void convertToPdf(File hocr,
			File image,
			FileOutputStream out) throws IOException,
			BadElementException, DocumentException {
		// parse the hocr file
		HocrParser parser = new HocrParser(hocr);
		HocrDocument document = parser.parse();
		Source source = new Source(hocr);

		// Find the tag of class ocr_page in order to load the scanned image
		StartTag pageTag = source.getNextStartTag(0, "class", "ocr_page", false);
		Matcher imageMatcher = imagePattern.matcher(pageTag.getElement().getAttributeValue("title"));
		if(!imageMatcher.find()) {
			logger.debug("Could not find a tag of class 'ocr_page'");
			return;
		}

		// Load the image
		Image pageImage = null;
		try {
			pageImage = Image.getInstance(image.getAbsolutePath());
		} catch (MalformedURLException e) {
			logger.debug("Could not load the scanned image from: " + image.getAbsolutePath() + ", aborting.");
			return;
		}

		float dotsPerPointX = pageImage.getDpiX() > 0.0 ? pageImage.getDpiX() : DEFAULT_DPI / DEFAULT_RESOLUTION;
		float dotsPerPointY = pageImage.getDpiY() > 0.0 ? pageImage.getDpiY() : DEFAULT_DPI / DEFAULT_RESOLUTION;
		logger.debug("dotsperpoint x = " + dotsPerPointX);
		logger.debug("dotsperpoint y = " + dotsPerPointY);
		Document pdf = new Document(new Rectangle(pageImage.getWidth() / dotsPerPointX, pageImage.getHeight() / dotsPerPointY));
		PdfWriter writer = PdfWriter.getInstance(pdf, out);
		pdf.open();

		// Put the text behind the picture
		PdfContentByte contentByte = writer.getDirectContentUnder();

		// process only the first page for now
		Page page = document.getPages().get(0);

		pageImage.scaleToFit(pageImage.getWidth() / dotsPerPointX, pageImage.getHeight() / dotsPerPointY);
		pageImage.setAbsolutePosition(0, 0);
		// Put the image in front of the text
		writer.getDirectContent().addImage(pageImage);

		List<Line> lines = page.getLines();
		for (Line line: lines) {
			contentByte.beginText();
			contentByte.setTextRenderingMode(PdfContentByte.TEXT_RENDER_MODE_INVISIBLE);

			List<Word> words = line.getWords();
			float lineHeight = line.getBoundingBox().getHeight() / dotsPerPointY;
			float fontSize = computeFontSize(line.getBoundingBox(), dotsPerPointY);
			contentByte.setFontAndSize(DEFAULT_FONT.getBaseFont(), fontSize);

			for (Word word: words) {
				adjustCharSpacing(contentByte, word, dotsPerPointX);

				float y = (page.getBoundingBox().getHeight() - lineHeight - line.getBoundingBox().getBottom()) / dotsPerPointY;
				float x = word.getBoundingBox().getLeft() / dotsPerPointX;

				contentByte.showTextAligned(PdfContentByte.ALIGN_LEFT, word.getTextContent(), x, y, 0);
				logger.debug("moving word " + word + " to " + x + "," + y);
			}
			contentByte.endText();
		}

		pdf.close();
	}

	private float computeFontSize(BoundingBox box, float dotsPerPointVertical) {
		float lineHeight = box.getHeight() / dotsPerPointVertical;
		float result = Math.round(lineHeight);
		if (result == 0.0f) {
			result = lineHeight;
		}

		return result;
	}

	private void adjustCharSpacing(PdfContentByte cb, Word word, float dotsPerPointsHorizontal) {
		float wordWidth = word.getBoundingBox().getWidth() / dotsPerPointsHorizontal;
		float charSpacing = 0;
		cb.setCharacterSpacing(charSpacing);

		float textWidthPt = cb.getEffectiveStringWidth(word.getTextContent(), false);


		if (textWidthPt > wordWidth) {
			while (textWidthPt > wordWidth) {
				charSpacing -= 0.05f;
				cb.setCharacterSpacing(charSpacing);
				float newTextWidthPt = cb.getEffectiveStringWidth(word.getTextContent(), false);
				// !!! deadlock
				if (newTextWidthPt == textWidthPt || charSpacing > -0.5f) {
					break;
				}
				else {
					textWidthPt = newTextWidthPt;
				}
			}
		} else {
			while (wordWidth > textWidthPt) {
				charSpacing += 0.1f;
				cb.setCharacterSpacing(charSpacing);
				float newTextWidthPt = cb.getEffectiveStringWidth(word.getTextContent(), false);
				// !!! deadlock
				if (newTextWidthPt == textWidthPt || charSpacing > 0.5f) {
					break;
				} else {
					textWidthPt = newTextWidthPt;
				}
			}
		}
	}

	class PageConverter {
		
	}
}

