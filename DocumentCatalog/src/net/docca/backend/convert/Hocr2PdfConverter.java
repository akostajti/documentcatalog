package net.docca.backend.convert;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.htmlparser.jericho.Element;
import net.htmlparser.jericho.Source;
import net.htmlparser.jericho.StartTag;

import org.apache.log4j.Logger;

import com.itextpdf.text.BadElementException;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Font;
import com.itextpdf.text.FontFactory;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;

public class Hocr2PdfConverter {
	private static final Logger logger = Logger.getLogger(Hocr2PdfConverter.class);

	/**
	 * the pattern used in finding the bbox properties.
	 */
	private static final Pattern bboxPattern = Pattern.compile("bbox(\\s+\\d+){4}");
	private static final Pattern imagePattern = Pattern.compile("image\\s+([^;]+)");

	/**
	 * used in finding the coordinates of the bboxes
	 */
	private final static Pattern bboxCoordinatePattern = Pattern.compile("(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)");

	/**
	 * the default dpi value used if it cannot be derived from the image itself.
	 */
	private static final float DEFAULT_DPI = 200.0f;

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			if(args.length < 1 || args[0] == "--help" || args[0] == "-h") {
				System.out.print(
						"Usage: java com.acoveo.hocrtopdf.HocrToPdf INPUTURL.html OUTPUTURL.pdf\n" +
						"\n" +
						"Converts hOCR files into PDF\n" +
						"\n" +
						"Example: java com.acoveo.hocrtopdf.HocrToPdf file:///home/username/hocr.html ./output.pdf\n");
				if(args.length < 1)
					System.exit(-1);
				else
					System.exit(0);
			}
			File inputHOCRFile = null;
			FileOutputStream outputPDFStream = null;
			try {
				inputHOCRFile = new File(args[0]);
			} catch (Exception e) {
				System.out.println("The first parameter has to be a valid URL");
				System.exit(-1);
			}
			try {
				outputPDFStream = new FileOutputStream(args[1]);
			} catch (FileNotFoundException e) {
				System.out.println("The second parameter has to be a valid URL");
				System.exit(-1);
			}
			
			convertToPdf(inputHOCRFile, outputPDFStream);
		} catch (DocumentException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**hOcr file (generated by tesseract)
	 * Processes a 
	 * 
	 * @param hocr
	 * @param out
	 * @throws IOException
	 * @throws BadElementException
	 * @throws DocumentException
	 */
	private static void convertToPdf(File hocr,
			FileOutputStream out) throws IOException,
			BadElementException, DocumentException {
		// The resolution of a PDF file (using iText) is 72pt per inch
		float pointsPerInch = 72.0f;

		Source source = new Source(hocr);

		// Find the tag of class ocr_page in order to load the scanned image
		StartTag pageTag = source.getNextStartTag(0, "class", "ocr_page", false);
		Matcher imageMatcher = imagePattern.matcher(pageTag.getElement().getAttributeValue("title"));
		if(!imageMatcher.find()) {
			logger.error("Could not find a tag of class 'ocr_page'");
			return;
		}

		// Load the image
		Image pageImage = null;
		try {
			pageImage = Image.getInstance(imageMatcher.group(1).replace("\"", ""));
		} catch (MalformedURLException e) {
			logger.error("Could not load the scanned image from: " + "file://" + imageMatcher.group(1) + ", aborting.");
			return;
		}

		float dotsPerPointX = pageImage.getDpiX() > 0.0 ? pageImage.getDpiX() : DEFAULT_DPI / pointsPerInch;
		float dotsPerPointY = pageImage.getDpiY() > 0.0 ? pageImage.getDpiY() : DEFAULT_DPI / pointsPerInch;
		float pageImagePixelHeight = pageImage.getHeight();
		Document pdfDocument = new Document(new Rectangle(pageImage.getWidth() / dotsPerPointX, pageImage.getHeight() / dotsPerPointY));
		PdfWriter pdfWriter = PdfWriter.getInstance(pdfDocument, out);
		pdfDocument.open();

		// first define a standard font for our text
		Font defaultFont = FontFactory.getFont(FontFactory.HELVETICA, 8, Font.BOLD, CMYKColor.BLACK);

		// Put the text behind the picture (reverse for debugging)
		PdfContentByte contentByte = pdfWriter.getDirectContentUnder();

		pageImage.scaleToFit(pageImage.getWidth() / dotsPerPointX, pageImage.getHeight() / dotsPerPointY);
		pageImage.setAbsolutePosition(0, 0);
		// Put the image in front of the text (reverse for debugging)
		pdfWriter.getDirectContent().addImage(pageImage);

		// using the bbox property to put the text behind the image at the correct place		
		
		// Only tags of the ocr_line class are interesting
		StartTag ocrLineTag = source.getNextStartTag(0, "class", "ocr_line", false);
		while(ocrLineTag != null) {
			Element lineElement = ocrLineTag.getElement();
			Matcher bboxMatcher = bboxPattern.matcher(lineElement.getAttributeValue("title"));
			if(bboxMatcher.find()) {
				// We found a tag of the ocr_line class containing a bbox property
				Matcher bboxCoordinateMatcher = bboxCoordinatePattern.matcher(bboxMatcher.group());
				bboxCoordinateMatcher.find();
				int[] coordinates = {Integer.parseInt((bboxCoordinateMatcher.group(1))),
						Integer.parseInt((bboxCoordinateMatcher.group(2))),
						Integer.parseInt((bboxCoordinateMatcher.group(3))),
						Integer.parseInt((bboxCoordinateMatcher.group(4)))};
				String line = lineElement.getContent().getTextExtractor().toString();
				float bboxWidthPt = (coordinates[2] - coordinates[0]) / dotsPerPointX;
				float bboxHeightPt = (coordinates[3] - coordinates[1]) / dotsPerPointY;
				
				// Put the text into the PDF
				contentByte.beginText();
				// Comment the next line to debug the PDF output (visible Text)
				contentByte.setTextRenderingMode(PdfContentByte.TEXT_RENDER_MODE_INVISIBLE);
				// TODO: Scale the text width to fit the OCR bbox
				contentByte.setFontAndSize(defaultFont.getBaseFont(), Math.round(bboxHeightPt));
				contentByte.moveText((float)(coordinates[0] / dotsPerPointX), (float)((pageImagePixelHeight - coordinates[3]) / dotsPerPointY));
				contentByte.showText(line);
				contentByte.endText();
			}
			ocrLineTag = source.getNextStartTag(ocrLineTag.getEnd(), "class", "ocr_line", false);
		}
		pdfDocument.close();
	}
}

