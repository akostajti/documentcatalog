/*
 * Copyright by Akos Tajti (akos.tajti@gmail.com)
 *
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Akos Tajti. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Akos Tajti.
 */
package net.docca.backend.convert.hocr;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.List;

import net.docca.backend.convert.AbstractConverter;
import net.docca.backend.convert.hocr.attributes.BoundingBox;
import net.docca.backend.convert.hocr.elements.Line;
import net.docca.backend.convert.hocr.elements.Page;
import net.docca.backend.convert.hocr.elements.Word;
import net.docca.backend.util.image.AbstractMultipageImageHandler;

import org.apache.log4j.Logger;
import org.apache.sanselan.ImageFormat;
import org.apache.sanselan.ImageInfo;
import org.apache.sanselan.ImageReadException;
import org.apache.sanselan.Sanselan;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Font;
import com.itextpdf.text.FontFactory;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;

/**
 * converts a hocr file (produced by an ocr application) to a pdf document. the resulting
 * pdf document has an image layer and a text layer. the image is in the foreground, the
 * text is in the background (each word positioned under the correct place in the image).
 * this makes the pdf searchable.
 *
 * @author Akos Tajti <akos.tajti@gmail.com>
 *
 */
public class HocrToPdfConverter extends AbstractConverter {
	/**
	 * the logger for ths class.
	 */
	private static Logger logger = Logger.getLogger(HocrToPdfConverter.class);

	/**
	 * the default dpi value used if it cannot be derived from the image itself.
	 */
	private static final float DEFAULT_DPI = 100.0f;

	/**
	 * the default resolution of the pdf file.
	 */
	private static final float DEFAULT_RESOLUTION = 72.0f;

	/**
	 * the default font used in the pdf documents.
	 */
	private static final Font DEFAULT_FONT =
			FontFactory.getFont(FontFactory.HELVETICA, 8, Font.BOLD, CMYKColor.BLACK);

	/**
	 * parses and converts a hOcr file (generated by tesseract) to pdf.
	 *
	 * @param hocr the hocr file to convert to pdf
	 * @param out the file output stream to write the pdf file to
	 * @throws IOException on any io error
	 * @throws DocumentException on any error when creating the pdf document
	 */
	@Override
	public final void convert(final File hocr,
			final FileOutputStream out) throws IOException,
			DocumentException {
		// parse the hocr file
		HocrParser parser = new HocrParser(hocr);
		HocrDocument document = parser.parse();

		convertToPdf(document, out);
	}

	/**
	 * converts a <code>HocrDocument</code> to pdf.
	 *
	 * @param document the parsed  hocr document to convert.
	 * @param out the output for writing the result.
	 * @throws DocumentException on any error when creating the pdf document
	 * @throws IOException on any io error
	 */
	public final void convertToPdf(final HocrDocument document, final FileOutputStream out)
			throws DocumentException, IOException {
		Document pdf = new Document();
		PdfWriter writer = PdfWriter.getInstance(pdf, out);

		try {
			// add the pages one by one
			PageConverter pageConverter = new PageConverter(pdf, writer);
			for (Page page: document.getPages()) {
				pageConverter.addPage(page);
			}
		} finally {
			if (pdf.isOpen()) {
				pdf.close(); // always try to close the document
			}
		}
	}


	/**
	 * not threadsafe.
	 *
	 * @author Akos Tajti <akos.tajti@gmail.com>
	 *
	 */
	class PageConverter {
		/**
		 * the resulting pdf document.
		 */
		private final Document document;

		/**
		 * the writer for creating the document.
		 */
		private final PdfWriter writer;

		/**
		 * creates a new instance.
		 * @param document the pdf document to use
		 * @param writer the writer
		 * @throws IOException on any io error
		 */
		public PageConverter(final Document document, final PdfWriter writer) throws IOException {
			this.document = document;
			this.writer = writer;
		}

		/**
		 * adds a page to the document.
		 * @param page the page to add
		 * @throws IOException on any io error
		 * @throws DocumentException on any exception when creating the document
		 */
		public final void addPage(final Page page) throws IOException, DocumentException {
			Image image = loadImage(page);
			if (image == null) {
				logger.info("failed to load the image for page " + page);
				return;
			}
			float dotsPerPointX = image.getDpiX() > 0.0 ? image.getDpiX()
					: DEFAULT_DPI / DEFAULT_RESOLUTION;
			float dotsPerPointY = image.getDpiY() > 0.0 ? image.getDpiY()
					: DEFAULT_DPI / DEFAULT_RESOLUTION;

			setupPage(image, page, dotsPerPointX, dotsPerPointY);
			openOrAddPage();
			addImage(page, image, dotsPerPointX, dotsPerPointY);

			addLines(page, dotsPerPointX, dotsPerPointY);
		}

		/**
		 * adds the background image to the document and sets its position.
		 *
		 * @param page the page to add the image to
		 * @param image the image
		 * @param dotsPerPointX dpix
		 * @param dotsPerPointY dpiy
		 * @throws DocumentException  on any exception when creating the document
		 */
		private void addImage(final Page page, final Image image, final float dotsPerPointX,
				final float dotsPerPointY) throws DocumentException {
			image.scaleToFit(page.getBoundingBox().getWidth()
					/ dotsPerPointX, page.getBoundingBox().getHeight() / dotsPerPointY);
			image.setAbsolutePosition(0, 0);
			writer.getDirectContent().addImage(image);
		}

		/**
		 * ensures that the page is open. if not then opens it else just adds a new page.
		 */
		private void openOrAddPage() {
			if (this.document.isOpen()) {
				document.newPage();
			} else {
				document.open();
			}
		}

		/**
		 * loads the background image using the <code>image</code> property
		 * of the page. handles windows file names correctly.
		 * also handles tff files with multiple pages.
		 * @param page the page to get the image name from
		 * @return the loaded image or null
		 */
		private Image loadImage(final Page page) {
			FileInputStream stream = null;
			String filename = page.getImage();
			filename = filename.replaceAll("\"", "");
			Image image = null;
			try {
				File source = new File(filename);
				stream = new FileInputStream(source);
				byte[] inBytes = new byte[stream.available()];
				stream.read(inBytes);

				// try to guess the image type
				ImageFormat imageFormat = Sanselan.guessFormat(inBytes);
				if (AbstractMultipageImageHandler.isMultipageFormat(imageFormat)) {
					image = AbstractMultipageImageHandler
							.getHandlerForFormat(imageFormat).getPageImage(page, inBytes);
				} else {
					image = Image.getInstance(inBytes);
				}
				correctImageDpi(image, inBytes);
				return image;
			} catch (Exception e) {
				logger.warn(e);
			} finally {
				if (stream != null) {
					try {
						stream.close();
					} catch (IOException e) {

					}
				}
			}
			return null;
		}

		/**
		 * itext is not able to find the dpi for each type of images. this method comutes the correct values
		 * using sanselan.
		 *
		 * @param image the image to use
		 * @param inBytes the byte contents of the image
		 * @throws ImageReadException couldn't read the image
		 * @throws IOException on any io error
		 */
		private void correctImageDpi(final Image image, final byte[] inBytes)
				throws ImageReadException, IOException {
			if (image != null) {
				// use Sanselan to get the image info and write it to the image
				ImageInfo info = Sanselan.getImageInfo(inBytes);
				image.setDpi(info.getPhysicalWidthDpi(), info.getPhysicalHeightDpi());
			}
		}

		/**
		 * sets up everything about the page (size, position etc.).
		 *
		 * @param image the image
		 * @param page the page
		 * @param dotsPerPointX dpix
		 * @param dotsPerPointY dpiy
		 * @throws DocumentException on any error during the modification of the document
		 */
		private void setupPage(final Image image, final Page page, final float dotsPerPointX,
				final float dotsPerPointY) throws DocumentException {
			Rectangle pageRectangle = new Rectangle(page.getBoundingBox().getWidth()
					/ dotsPerPointX, page.getBoundingBox().getHeight() / dotsPerPointY);
			logger.debug("page size for page " + page.getId() + ": " + pageRectangle);
			document.setPageSize(pageRectangle);
			logger.debug("dotsperpoint x = " + dotsPerPointX);
			logger.debug("dotsperpoint y = " + dotsPerPointY);
		}

		/**
		 * adds the lines of the page to the pdf.
		 *
		 * @param page the page
		 * @param dotsPerPointX dpix
		 * @param dotsPerPointY dpiy
		 */
		private void addLines(final Page page, final float dotsPerPointX,
				final float dotsPerPointY) {
			PdfContentByte contentBackground = writer.getDirectContentUnder();
			List<Line> lines = page.getLines();
			for (Line line: lines) {
				contentBackground.beginText();
				contentBackground.setTextRenderingMode(PdfContentByte.TEXT_RENDER_MODE_INVISIBLE);

				List<Word> words = line.getWords();
				float lineHeight = line.getBoundingBox().getHeight() / dotsPerPointY;
				float fontSize = computeFontSize(line.getBoundingBox(), dotsPerPointY);
				contentBackground.setFontAndSize(DEFAULT_FONT.getBaseFont(), fontSize);

				for (Word word: words) {
					adjustCharSpacing(contentBackground, word, dotsPerPointX);

					float y = (page.getBoundingBox().getHeight() - lineHeight
							- line.getBoundingBox().getBottom()) / dotsPerPointY;
					float x = word.getBoundingBox().getLeft() / dotsPerPointX;

					contentBackground.showTextAligned(PdfContentByte.ALIGN_LEFT,
							word.getTextContent(), x, y, 0);
					logger.debug("moving word " + word + " to " + x + "," + y);
				}
				contentBackground.endText();
			}
		}

		/**
		 * computes the font size based on the bounding box of the line.
		 *
		 * @param box the bonding box
		 * @param dotsPerPointVertical dpiy
		 * @return the computed font size
		 */
		private float computeFontSize(final BoundingBox box, final float dotsPerPointVertical) {
			float lineHeight = box.getHeight() / dotsPerPointVertical;
			float result = Math.round(lineHeight);
			if (result == 0.0f) {
				result = lineHeight;
			}

			return result;
		}

		/**
		 * adjust the character spacing. the mechanism is really simple: reduce/increase the spacing until
		 * the word width is the same as it was on the original image.
		 *
		 * @param contentByte the pdf content byte object used for setting the pdf properties
		 * @param word the word in which the character spacing will be adjusted
		 * @param dotsPerPointsHorizontal dpix
		 */
		private void adjustCharSpacing(final PdfContentByte contentByte, final Word word,
				final float dotsPerPointsHorizontal) {
			float wordWidth = word.getBoundingBox().getWidth() / dotsPerPointsHorizontal;
			float spacing = 0;
			contentByte.setCharacterSpacing(spacing);

			float textWidth = contentByte.getEffectiveStringWidth(word.getTextContent(), false);

			if (textWidth > wordWidth) {
				while (textWidth > wordWidth) {
					spacing -= 0.05;
					contentByte.setCharacterSpacing(spacing);
					float newTextWidth = contentByte.getEffectiveStringWidth(word.getTextContent(),
							false);
					if (newTextWidth == textWidth || spacing > -0.5) {
						break;
					}
					else {
						textWidth = newTextWidth;
					}
				}
			} else {
				while (wordWidth > textWidth) {
					spacing += 0.1;
					contentByte.setCharacterSpacing(spacing);
					float newTextWidth = contentByte.getEffectiveStringWidth(word.getTextContent(),
							false);
					if (newTextWidth == textWidth || spacing > 0.5) {
						break;
					} else {
						textWidth = newTextWidth;
					}
				}
			}
		}
	}
}

